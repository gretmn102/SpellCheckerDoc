# SpellChecker
## Зочем?
Свою реализацию набыдлокодил где-то 20.07.2020, только сперва перерыл все имеющиеся аналоги, и они все либо глючили, либо не работали, потому что требовали 999 Винду, подключение к Яндекс.Словарю (да-да, был и такой эпик) и т.п. Ох, как я же возненавидел, скажем, [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker), и это тормозящее говно еще собирает пожертвования, грр! Ладно, не такое уж оно барахло, потому что у него богатый функционал, но зачем, если оно глючит?!

В общем, штука нужная хотя бы мне, а если народ узнает, что появился шустрый аналог, я уверен, что и они подтянутся. Да и вообще, такое не стыдно выставить, скажем, в портфолио.

## Что это такое?
Если просто, то это функция вида `parse: (dictionary: string [], input: string): Error []`, где `Error = { Range: int * int; Line: int }`. Но, как говорится, дьявол кроется в деталях, но пока нужно разобраться с кое-чем поважнее.

## Сервер или библиотека?
Допустим, мы напишем функцию, но как ее связать с целевым окружением? И шо воно вообще таке?
Расширения VS Code работают на платформе Node.js, а значит, усё пишется JS. Связок может быть две:
1. Сервер. Пожалуй, это не совсем верное название, а скорее, дочерний процесс, который запускается по велению расширения VS Code и разговаривает между собой потоками, э-э, хм... Ну, банальный `print("Hello World")` выводится на "консоль", верно? А консоль — это процесс, который запустил этот Hello World и считал с его потока данные. Вот ты сишник, вот мне и объяснишь, как это работает, хы-хы-хы. Копать [`stdout`](https://cplusplus.com/reference/cstdio/stdout/), `stdin`. Это самая простая и интуитивная связь между двумя процессами, я щитаю. Хотя можно еще пробросить через socket'ы (т.е. по локальной сети, если говорить по нашему), но ее обсудим как-нибудь потом.
2. Библиотека. Набор функций, написанный в данном случае на C++, а расширение, написанное на Node.js, должно каким-то образом использовать скомпилированную библиотеку.

Честно, второй вариант мне вообще никак не нравится, потому что ~~мне лень копаться в расширении и его дописывать~~ есть такая штука как [Language Server Protocol](https://microsoft.github.io/language-server-protocol/specifications/specification-current/). Что это значит? Если мы сделали некий сервер, то должны общаться с ним по определенным правилам (протоколу), чтобы запрашивать что-то и получать предсказуемый ответ. Именно для поддержки языков (language provider) Microsoft запилил спецификацию для Visual Studio и VS Code. Кстати, стоит отметить, что LSP написан для всех, т.е. любой редактор может взять и воплотить эту спецификацию у себя, а потом использовать наш, к примеру, сервачок. Очень удобно и круто, ящитаю. Т.е. пишем мы не только для VS Code, но для любого редактора, который поддерживает этот протокол. Только у каждого свой юмор с их связкой (как, например, у VS Code — расширение), но это уже отдельный вопрос.

В общем, я голосую за вариант с LSP.
## Есть ли реализация LSP для C++?
А черт его знает. Надо погуглить. В любом случае, это оно не так уж сложно пишется, да и можно реализовать только нужные нам методы из [спецификации](https://microsoft.github.io/language-server-protocol/specifications/specification-current/), выложить его в отдельное хранилище, а остальное пусть пилят сами, кому надо. Еще один будет плюс для общества.

## Какой парсер использовать и что вообще нужно парсить?
Дело в том, что простое регулярное выражение `\w+` нам не подходит: входная строка — это исходник на каком-нибудь языке. Глупо проверять орфографию во всех токенах языка, когда лучше проверить ее, скажем, в комментариях.

```fsharp
let foo = // распарси меня
    // ...
```

Так, что же брать?
— Только без фанатизма, — говорю я, а сам достаю связку [Lex&YACC](https://www.linuxhowtos.org/C_C++/lex_yacc.htm), ага.
Но с другой стороны, самопал плох, потому что рано или поздно изобретается один из возможных типов парсеров, только в разы хуже и непонятнее. Так что я голосую за какой-нибудь существующий парсер.
Я, например, написал на комбинаторном парсере FParsec, но иди знай, есть ли такое чудо техники в C++. С Lex&YACC познакомился ещо в 2016, кажется, году. Странная штука, но более-менее понятная. Надо обсуждать ¯\\\_(ツ)_/¯

## Итог
* Программа будет состоять из следующих независимых частей:
    * LSP
    * Parser
    * Suggestions — выпадающие подсказки, которые предлагают исправление слов. О нем позже.
* Срок всего этого дела: а черт его знает, если учесть, что мы едва знаем C++
* Хранилище: GitHub — лучше места не придумаешь. Там есть два варианта:
     * Организация, т.е. мы, как два человека, создаем и трудимся над проектом (возможно, не последним, да).
     * Прям на твоем аккаунте бахнуть, а я в случае чего, могу у себя пометить, что работал над этим проектом. Впрочем, с организацией работает точно по такому же принципу.

    В любом случае, когда коммитишь, там обязательно записывается, кто коммитил и когда, так что вклад — это вообще не вопрос.

Да и усё, пожалуй. Знаю, вопросов у тебя куча, но предлагаю их решить голосом, ибо чёт я устал, дя. А по итогу разговора буду исправлять/дополнять сѣй документъ.
